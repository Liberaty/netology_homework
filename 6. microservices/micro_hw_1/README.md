# Домашнее задание к занятию «Введение в микросервисы» - Лепишин Алексей

## Задача

Руководство крупного интернет-магазина, у которого постоянно растёт пользовательская база и количество заказов, рассматривает возможность переделки своей внутренней ИТ-системы на основе микросервисов. 

Вас пригласили в качестве консультанта для оценки целесообразности перехода на микросервисную архитектуру. 

Опишите, какие выгоды может получить компания от перехода на микросервисную архитектуру и какие проблемы нужно решить в первую очередь.

---
## Решение

## Оглавление

- [Выгоды от перехода на микросервисы](#выгоды-от-перехода-на-микросервисы)
- [Проблемы, которые нужно решить в первую очередь](#проблемы-которые-нужно-решить-в-первую-очередь)
- [Перед полномасштабным переходом рекомендуется](#перед-полномасштабным-переходом-рекомендуется)
- [Чек-лист старта](#чек-лист-старта)

---

## Выгоды от перехода на микросервисы

- **Масштабирование по потребности**
  - Линейно масштабируем «горячие» участки (каталог, корзина, checkout) без наращивания всего монолита.
  - Разные сервисы могут иметь разные профили ресурсов (CPU-heavy для поиска, memory-heavy для рекомендаций).

- **Независимые релизы и скорость изменений**
  - Каждая команда релизит свой сервис автономно.
  - Меньше координации, выше частота деплоев, быстрее time-to-market.
  - Возможность Blue/Green, Canary и A/B-тестирования на уровне отдельных сервисов.

- **Технологический выбор**
  - Подбираем стек под задачу (Go/Java для high-load, Python для ML и т.п.).

- **Отказоустойчивость и локализация инцидентов**
  - Отказ одного сервиса не «роняет» весь сайт (при корректной конфигурации таймаутов, ретраев и fallback).
  - Границы сервисов ограничивают последствия инцидентов.

- **Организационная масштабируемость**
  - Команды владеют сервисами end-to-end: от кода до продакшена.
  - Архитектура отражает структуру команд (Conway’s Law).

- **Удобство экспериментов**
  - Новые возможности (рекомендательная система, антифрод, loyalty) можно добавлять как отдельные сервисы, не ломая ядро.

---

## Проблемы, которые нужно решить в первую очередь

1. **Границы доменов и модель данных**
   - Определить bounded contexts: «Каталог», «Ценообразование», «Склад», «Заказы», «Оплата», «Доставка», «Профиль/Лояльность», «Поиск».
   - Каждая команда владеет своей БД. Межсервисное взаимодействие — через API/события, а не прямой доступ к таблицам.

2. **Согласованность данных и транзакции**
   - Отказ от распределённых ACID.
   - Использование саг, outbox-паттерна, idempotency-ключей.
   - Определить, где нужна strong consistency, а где eventual.

3. **Сетевые контракты**
   - API Gateway, версияция контрактов, consumer-driven contract testing.
   - Таймауты, ретраи с backoff, circuit breaker, rate limiting.

4. **Наблюдаемость**
   - Единые стандарты логов (trace-id), метрик (RED/USE), distributed tracing.
   - Централизованный алертинг и SLO.

5. **Сеть и коммуникации**
   - Определить, где использовать синхронное (HTTP/gRPC), а где асинхронное взаимодействие (Kafka/RabbitMQ).
   - Продумать QoS для очередей, дедубликацию, гарантии доставки.

6. **Безопасность**
   - Сквозная аутентификация/авторизация (OIDC/JWT), mTLS, управление секретами.
   - Для e-commerce в ЕС — учёт GDPR: минимизация PII, шифрование, политика хранения данных.

7. **CI/CD и платформа исполнения**
   - Стандартизированные pipeline’ы, автотесты, скан безопасности.
   - Контейнерная оркестрация (Kubernetes), сервис-мэш, автоскейлинг.

8. **Стоимость и сложность**
   - Появится дополнительный оверхед: инфраструктура, команда платформы, поддержка наблюдаемости и брокеров сообщений.

---

## Перед полномасштабным переходом рекомендуется

1. **Оценка текущей системы и целей**
   - Зафиксировать целевые метрики: скорость релизов, доступность, p95, MTTR и др.
   - Построить карту домена и зависимостей.

2. **Выбор пилота**
   - Начать с одного сервиса (например, «каталог» или «корзина/checkout»).
   - Использовать Strangler Fig: постепенно выносить куски из монолита.

3. **Минимальная платформа и стандарты**
   - Контейнеры, реестр образов, CI/CD pipeline’ы, централизованные логи и метрики.
   - Общие гайды по API, SLA/SLO, таймаутам и ретраям.

4. **Архитектурные паттерны**
   - Outbox/inbox, saga, idempotency, dead-letter queues, circuit breaker.

5. **Безопасность by design**
   - Identity provider (OIDC), минимальные привилегии, аудит, секрет-менеджмент.

6. **Организация и ответственность**
   - Команды «по доменам», подход you build it, you run it.
   - Каждый сервис должен иметь владельца.

7. **План миграции и критерии «готово»**
   - Дорожная карта: пилот → расширение → декомпозиция монолита.
   - Метрики для оценки: SLO, MTTR, скорость релизов.

8. **Подход к данным**
   - План миграции БД: двойная запись, репликация, теневые чтения.
   - Каталог данных и ответственность за схемы.

---

## Чек-лист старта

- [ ] Срез бизнес-метрик и карта домена  
- [ ] Выбор пилотного сервиса + план Strangler  
- [ ] CI/CD шаблоны, реестр, observability MVP  
- [ ] Единые сетевые политики (timeouts/retries/circuit breaker)  
- [ ] AuthZ/AuthN (OIDC/JWT), секрет-менеджмент  
- [ ] Паттерны согласованности (Saga, Outbox, Idempotency)  
- [ ] SLO/алертинг, дежурства, runbook’и  
- [ ] План миграции данных и GDPR-контур